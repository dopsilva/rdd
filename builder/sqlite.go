package builder

import (
	"fmt"
	"strings"

	"github.com/dopsilva/rdd/field"
	"github.com/dopsilva/rdd/schema"
)

type SQLite struct {
}

func (e SQLite) CreateTable(table *schema.Table, options *CreateTableOptions) (string, error) {
	var b strings.Builder
	pk := make([]schema.Field, 0)
	var uk *schema.Field
	opt := CreateTableOptions{}

	if options != nil {
		opt = *options
	}

	if opt.DropIfExists {
		b.WriteString("drop table if exists " + e.QuotedIdentifier(table.Name) + ";")
	}

	b.WriteString("create table")

	if opt.IfNotExists {
		b.WriteString(" if not exists")
	}

	b.WriteString(" " + e.QuotedIdentifier(table.Name) + " (")

	n := 0
	for _, f := range table.Fields {
		if n > 0 {
			b.WriteString(", ")
		}
		b.WriteString(e.createColumn(f))
		if f.PrimaryKey {
			pk = append(pk, f)
		}
		if f.UniqueKey {
			uk = &f
		}
		n++
	}

	if len(pk) > 0 {
		cn := "pk_" + table.Name
		for _, f := range pk {
			cn += "_" + f.Name
		}
		b.WriteString(", constraint " + cn + " primary key (")
		for i, f := range pk {
			if i > 0 {
				b.WriteString(", ")
			}
			b.WriteString(e.QuotedIdentifier(f.Name))
		}
		b.WriteString(")")
	}

	if uk != nil {
		cn := "uk_" + uk.Name
		b.WriteString(", constraint " + cn + " unique (" + e.QuotedIdentifier(uk.Name) + ")")
	}

	if len(table.ForeignKeys) > 0 {
		b.WriteString(",")
		for _, c := range table.ForeignKeys {
			cn := "fk"
			cf := ""
			for i, f := range c.Fields {
				if i > 0 {
					cf += ", "
				}
				cn += "_" + f
				cf += e.QuotedIdentifier(f)
			}
			b.WriteString(" constraint " + cn + " foreign key (" + cf + ") references " + e.QuotedIdentifier(c.Reference))
		}
	}

	b.WriteString(");")
	//fmt.Println(b.String())

	return b.String(), nil

}

func (e SQLite) createColumn(f schema.Field) string {
	var b strings.Builder

	b.WriteString(e.QuotedIdentifier(f.Name))

	//fmt.Println(f.fieldtype)

	switch f.FieldType {
	case "string", "NullString":
		b.WriteString(" text")
	case "int", "int64", "NullInt64":
		b.WriteString(" integer")
	case "bool", "NullBool":
		b.WriteString(" integer")
	case "float64", "NullFloat64":
		b.WriteString(" real")
	case "Time", "NullTime":
		b.WriteString(" text")
	}

	if f.Nullable {
		b.WriteString(" null")
	} else {
		b.WriteString(" not null")
	}

	if f.Default != "" {
		b.WriteString(" default ")
		switch f.Default {
		case "new_uuid":
			b.WriteString(e.DefaultRandomUUID())
		case "now":
			b.WriteString(e.DefaultCurrentTimestamp())
		}
	}

	return b.String()
}

func (e SQLite) Insert(table schema.Table, fields []field.FieldInstance) (string, []any, []any, error) {
	var q strings.Builder
	arguments := make([]any, 0)
	retfields := make([]field.FieldInstance, 0)
	returning := make([]any, 0)

	q.WriteString("insert into " + e.QuotedIdentifier(table.Name) + " (")

	n := 0
	for _, f := range fields {
		if f.Schema.AutoGenerated {
			retfields = append(retfields, f)
			returning = append(returning, f.Addr)
			continue
		}
		if ci, ok := f.Addr.(field.Changeable); ok {
			// não alterou o campo, ignora
			if !ci.Changed() {
				continue
			}
		}
		if n > 0 {
			q.WriteString(", ")
		}
		q.WriteString(e.QuotedIdentifier(f.Schema.Name))
		arguments = append(arguments, f.Addr)
		n++
	}

	q.WriteString(") values (")

	for i := range arguments {
		if i > 0 {
			q.WriteString(", ")
		}
		q.WriteString(fmt.Sprintf("$%d", i+1))
	}

	q.WriteString(")")

	if len(retfields) > 0 {
		q.WriteString(" returning ")

		n = 0
		for _, v := range retfields {
			if n > 0 {
				q.WriteString(", ")
			}
			q.WriteString(e.QuotedIdentifier(v.Schema.Name))
			n += 1
		}
	}

	q.WriteString(";")

	return q.String(), arguments, returning, nil
}

func (e SQLite) Update(schema schema.Table, fields []field.FieldInstance) (string, []any, []any, error) {
	var q strings.Builder
	arguments := make([]any, 0)
	retfields := make([]field.FieldInstance, 0)
	returning := make([]any, 0)
	pk := make([]field.FieldInstance, 0)

	q.WriteString("update " + e.QuotedIdentifier(schema.Name) + " set ")

	n := 0
	i := 1
	for _, v := range fields {
		if v.Schema.PrimaryKey {
			pk = append(pk, v)
		}
		if v.Schema.AutoGenerated && !v.Schema.PrimaryKey {
			retfields = append(retfields, v)
			returning = append(returning, v.Addr)
			continue
		}
		if c, ok := v.Addr.(field.Changeable); ok {
			if !c.Changed() {
				continue
			}
		} else if !ok {
			continue
		}
		if n > 0 {
			q.WriteString(", ")
		}
		q.WriteString(e.QuotedIdentifier(v.Schema.Name) + " = " + fmt.Sprintf("$%d", i))
		arguments = append(arguments, v.Addr)
		n++
		i++
	}

	if len(retfields) > 0 {
		q.WriteString(" returning ")

		n = 0
		for _, v := range retfields {
			if n > 0 {
				q.WriteString(", ")
			}
			q.WriteString(e.QuotedIdentifier(v.Schema.Name))
			n += 1
		}
	}

	q.WriteString(" where ")

	if where, wargs, ok := e.wherePrimaryKey(fields, len(arguments)); ok {
		q.WriteString(where)
		arguments = append(arguments, wargs...)
	} else if where, wargs, ok = e.whereUniqueKey(fields, len(arguments)); ok {
		q.WriteString(where)
		arguments = append(arguments, wargs...)
	} else {
		panic("update: tabela sem primary ou unique key definido")
	}

	q.WriteString(";")

	return q.String(), arguments, returning, nil
}

func (e SQLite) Delete(schema schema.Table, fields []field.FieldInstance) (string, []any) {
	var sb strings.Builder
	var where string
	var wargs []any
	var ok bool

	sb.WriteString("delete from " + e.QuotedIdentifier(schema.Name))
	sb.WriteString(" where ")

	if where, wargs, ok = e.wherePrimaryKey(fields, 0); ok {
		sb.WriteString(where)
	} else if where, wargs, ok = e.whereUniqueKey(fields, 0); ok {
		sb.WriteString(where)
	} else {
		panic("delete: tabela sem primary ou unique key definido")
	}

	return sb.String(), wargs
}

// wherePrimaryKey cria a condição para a clausula where baseada na primary key da tabela
func (e SQLite) wherePrimaryKey(fields []field.FieldInstance, argsCount int) (string, []any, bool) {
	var sb strings.Builder
	args := make([]any, 0)
	haspk := false

	i := 0
	for _, v := range fields {
		if v.Schema.PrimaryKey {
			if i > 0 {
				sb.WriteString(" and ")
			}
			sb.WriteString(e.QuotedIdentifier(v.Schema.Name) + " = " + fmt.Sprintf("$%d", argsCount+i+1))
			args = append(args, v.Addr)
			haspk = true
		}
	}

	return sb.String(), args, haspk
}

// whereUniqueKey cria a condição para a clausula where baseada na unique key da tabela
func (e SQLite) whereUniqueKey(fields []field.FieldInstance, argsCount int) (string, []any, bool) {
	var sb strings.Builder
	args := make([]any, 0)
	hasuk := false

	i := 0
	for _, v := range fields {
		if v.Schema.UniqueKey {
			if i > 0 {
				sb.WriteString(" and ")
			}
			sb.WriteString(e.QuotedIdentifier(v.Schema.Name) + " = " + fmt.Sprintf("$%d", argsCount+i+1))
			args = append(args, v.Addr)
			hasuk = true
		}
	}

	return sb.String(), args, hasuk
}

func (e SQLite) QuotedIdentifier(i string) string { return fmt.Sprintf("\"%s\"", i) }
func (e SQLite) QuotedValue(v any) string         { return "" }
func (e SQLite) DefaultRandomUUID() string        { return "(gen_random_uuid())" }
func (e SQLite) DefaultCurrentTimestamp() string  { return "current_timestamp" }

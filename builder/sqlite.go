package builder

import (
	"fmt"
	"strings"

	"github.com/dopsilva/rdd/field"
	"github.com/dopsilva/rdd/schema"
)

type SQLite struct {
}

func (e SQLite) CreateTable(table *schema.Table, options *CreateTableOptions) (string, error) {
	var b strings.Builder
	pk := make([]schema.Field, 0)
	var uk *schema.Field
	opt := CreateTableOptions{}

	if options != nil {
		opt = *options
	}

	if opt.DropIfExists {
		b.WriteString("drop table if exists " + e.QuotedIdentifier(table.Name) + ";")
	}

	b.WriteString("create table")

	if opt.IfNotExists {
		b.WriteString(" if not exists")
	}

	b.WriteString(" " + e.QuotedIdentifier(table.Name) + " (")

	n := 0
	for _, f := range table.Fields {
		if n > 0 {
			b.WriteString(", ")
		}
		b.WriteString(e.createColumn(f))
		if f.PrimaryKey {
			pk = append(pk, f)
		}
		if f.UniqueKey {
			uk = &f
		}
		n++
	}

	if len(pk) > 0 {
		cn := "pk_" + table.Name
		for _, f := range pk {
			cn += "_" + f.Name
		}
		b.WriteString(", constraint " + cn + " primary key (")
		for i, f := range pk {
			if i > 0 {
				b.WriteString(", ")
			}
			b.WriteString(e.QuotedIdentifier(f.Name))
		}
		b.WriteString(")")
	}

	if uk != nil {
		cn := "uk_" + uk.Name
		b.WriteString(", constraint " + cn + " unique (" + e.QuotedIdentifier(uk.Name) + ")")
	}

	if len(table.ForeignKeys) > 0 {
		b.WriteString(",")
		for _, c := range table.ForeignKeys {
			cn := "fk"
			cf := ""
			for i, f := range c.Fields {
				if i > 0 {
					cf += ", "
				}
				cn += "_" + f
				cf += e.QuotedIdentifier(f)
			}
			b.WriteString(" constraint " + cn + " foreign key (" + cf + ") references " + e.QuotedIdentifier(c.Reference))
		}
	}

	b.WriteString(");")
	//fmt.Println(b.String())

	return b.String(), nil

}

func (e SQLite) createColumn(f schema.Field) string {
	var b strings.Builder

	b.WriteString(e.QuotedIdentifier(f.Name))

	//fmt.Println(f.fieldtype)

	switch f.FieldType {
	case "string", "NullString":
		b.WriteString(" text")
	case "int", "int64", "NullInt64":
		b.WriteString(" integer")
	case "bool", "NullBool":
		b.WriteString(" integer")
	case "float64", "NullFloat64":
		b.WriteString(" real")
	case "Time", "NullTime":
		b.WriteString(" text")
	}

	if f.Nullable {
		b.WriteString(" null")
	} else {
		b.WriteString(" not null")
	}

	if f.Default != "" {
		b.WriteString(" default ")
		switch f.Default {
		case "new_uuid":
			b.WriteString(e.DefaultRandomUUID())
		case "now":
			b.WriteString(e.DefaultCurrentTimestamp())
		}
	}

	return b.String()
}

func (e SQLite) Insert(table schema.Table, fields []field.FieldInstance) (string, []any, []any, error) {
	var q strings.Builder
	arguments := make([]any, 0)
	retfields := make([]field.FieldInstance, 0)
	returning := make([]any, 0)

	q.WriteString("insert into " + e.QuotedIdentifier(table.Name) + "(")

	n := 0
	for _, f := range fields {
		if f.Schema.AutoGenerated {
			retfields = append(retfields, f)
			returning = append(returning, f.Addr)
			continue
		}
		if ci, ok := f.Addr.(field.Changeable); ok {
			// nÃ£o alterou o campo, ignora
			if !ci.Changed() {
				continue
			}
		}
		if n > 0 {
			q.WriteString(", ")
		}
		q.WriteString(e.QuotedIdentifier(f.Schema.Name))
		arguments = append(arguments, f.Addr)
		n++
	}

	return "", []any{}, []any{}, nil
}

func (e SQLite) Update(schema.Table, []field.Fieldable) (string, []any, []any, error) {
	return "", []any{}, []any{}, nil
}

func (e SQLite) Delete(schema.Table, []field.Fieldable) (string, []any) {
	return "", []any{}
}

func (e SQLite) QuotedIdentifier(i string) string { return fmt.Sprintf("\"%s\"", i) }
func (e SQLite) QuotedValue(v any) string         { return "" }
func (e SQLite) DefaultRandomUUID() string        { return "(gen_random_uuid())" }
func (e SQLite) DefaultCurrentTimestamp() string  { return "current_timestamp" }

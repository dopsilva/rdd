package rdd

import (
	"context"
	"errors"
	"reflect"
	"strconv"
	"sync"
	"time"

	"github.com/dopsilva/rdd/field"
	"github.com/dopsilva/rdd/schema"
)

type Workarea[T any] interface {
	Schema() *schema.Table
	Entity() string

	// Append realiza um insert no banco de dados
	Append(ctx context.Context, db Database) error
	// Replace realiza um update no banco de dados
	Replace(ctx context.Context, db Database) error
	// Remove realiza um delete no banco de dados
	Remove(ctx context.Context, db Database) error

	Changed() bool
	Load(src any) error
	Freeze()
	Reset()

	GetFieldsAddr(columns []string) []any

	Seek(db Database) error
	SeekUnique(db Database) error

	Close()

	Triggable
}

type Triggable interface {
	BeforeAppend(params EventParameters) error
	AfterAppend(params EventParameters) error
	BeforeReplace(params EventParameters) error
	AfterReplace(params EventParameters) error
	BeforeRemove(params EventParameters) error
	AfterRemove(params EventParameters) error
	AfterCommit(params EventParameters) error
	OnError(err error, params EventParameters) error
}

type workarea[T any] struct {
	entity *T
	schema *schema.Table
	fields map[string]field.FieldInstance
	lastop Operation
}

type Operation int

const (
	None Operation = iota
	Append
	Replace
	Delete
)

type EventParameters struct {
	Context   context.Context
	Database  Database
	Operation Operation
}

var (
	entitiesPool  = make(map[string]*sync.Pool, 0)
	entitiesMutex = sync.Mutex{}
)

// Use faz o uso da entidade. Importante que após o uso, a entidade seja fechada com Close.
func Use[T any]() *T {
	var e *T

	en := reflect.TypeOf(e).Elem().Name()
	p, ok := entitiesPool[en]
	if !ok {
		entitiesMutex.Lock()

		p = &sync.Pool{
			New: func() any {
				// instancia a entidade
				i := new(T)

				// instancia a workarea
				w := newWorkarea[T](i)

				// define a entidade a workarea
				// TODO: verificar se o field Workarea existe
				reflect.ValueOf(i).Elem().FieldByName("Workarea").Set(reflect.ValueOf(w))

				return i
			},
		}
		entitiesPool[en] = p

		entitiesMutex.Unlock()
	}

	return p.Get().(*T)
}

// Entity retorna o nome da entidade (estrutura em go)
func (w *workarea[T]) Close() {
	// reseta os valores
	w.Reset()
	// armazena no pool
	entitiesPool[w.Entity()].Put(w.entity)
}

func newWorkarea[T any](entity *T) Workarea[T] {
	schemaCached := true

	w := &workarea[T]{
		entity: entity,
		fields: make(map[string]field.FieldInstance, 0),
	}

	rv := reflect.ValueOf(entity).Elem()
	rt := reflect.TypeOf(entity).Elem()

	if v, ok := registeredSchemas[rt.Name()]; ok {
		w.schema = v
	} else {
		w.schema = &schema.Table{}
		w.schema.Fields = make(map[string]schema.Field, 0)
		schemaCached = false
	}

	for i := 0; i < rv.NumField(); i++ {
		f := rv.Field(i).Addr()

		switch v := f.Interface().(type) {
		case *Workarea[T]:
			if !schemaCached {
				if tv, ok := rt.Field(i).Tag.Lookup("rdd-table"); ok {
					w.schema.Name = tv
				} else {
					panic(errors.New("workarea: rdd-table not defined"))
				}
			}
		default:
			if ti, ok := v.(field.Typed); ok {
				columnName, ok := rt.Field(i).Tag.Lookup("rdd-column")
				if ok {
					// se não está cacheado o schema, lemos as informações das tags
					if !schemaCached {
						var pk, uk, auto, nullable bool
						var def string

						if tv, ok := rt.Field(i).Tag.Lookup("rdd-primary-key"); ok {
							pk, _ = strconv.ParseBool(tv)
						}
						if tv, ok := rt.Field(i).Tag.Lookup("rdd-unique-key"); ok {
							uk, _ = strconv.ParseBool(tv)
						}
						if tv, ok := rt.Field(i).Tag.Lookup("rdd-auto-generated"); ok {
							auto, _ = strconv.ParseBool(tv)
						}
						if tv, ok := rt.Field(i).Tag.Lookup("rdd-nullable"); ok {
							nullable, _ = strconv.ParseBool(tv)
						} else {
							nullable = false
						}
						if tv, ok := rt.Field(i).Tag.Lookup("rdd-default"); ok {
							def = tv
						}

						w.schema.Fields[columnName] = schema.Field{
							Name:          columnName,
							PrimaryKey:    pk,
							UniqueKey:     uk,
							AutoGenerated: auto,
							Nullable:      nullable,
							Default:       def,
							FieldType:     ti.Type().Name(),
						}
					}

					fi := field.FieldInstance{
						Schema: w.schema.Fields[columnName],
						Addr:   f.Interface(),
						Type:   ti.Type().Name(),
					}

					// armazena a instância do campo
					// para facilitar algumas operações
					w.fields[columnName] = fi
				}
			} else {
				// se não está cacheado o schema, lemos as informações das tags
				if !schemaCached {
					var fkf, fkr string
					if tv, ok := rt.Field(i).Tag.Lookup("rdd-foreign-key"); ok {
						fkf = tv
						if tv, ok := rt.Field(i).Tag.Lookup("rdd-foreign-key-reference"); !ok {
							panic("foreign key sem referência")
						} else {
							fkr = tv
						}
						w.schema.ForeignKeys = append(w.schema.ForeignKeys, schema.ForeignKey{Fields: []string{fkf}, Reference: fkr})
					}
				}
			}
		}
	}

	// se não está cacheado o schema, colocamos no cache
	if !schemaCached {
		registeredSchemas[rt.Name()] = w.schema
	}

	return w
}

// Schema retorna o schema da workarea
func (w *workarea[T]) Schema() *schema.Table {
	return w.schema
}

// Entity retorna o nome da entidade (estrutura em go)
func (w *workarea[T]) Entity() string {
	return reflect.TypeOf(w.entity).Elem().Name()
}

// GetFieldsAddr retorna a lista de endereços dos campos através do seu nome de coluna
func (w *workarea[T]) GetFieldsAddr(columns []string) []any {
	r := make([]any, 0)

	for _, c := range columns {
		for k, v := range w.fields {
			if c == k {
				r = append(r, v.Addr)
			}
		}
	}

	return r
}

// Append realiza um insert no banco de dados
func (w *workarea[T]) Append(ctx context.Context, db Database) error {
	// verifica se a entidade implementa o event handler
	handler, hasHandler := implements[Workarea[T]](w)

	// executa o event handler
	if hasHandler {
		if err := handler.BeforeAppend(EventParameters{Context: ctx, Database: db}); err != nil {
			return err
		}
	}

	// executa o insert
	query, args, ret, err := db.Builder().Insert(*w.schema, w.Fields())
	if err != nil {
		return err
	}

	//fmt.Println(query)

	if len(ret) == 0 {
		if _, err := db.Exec(query, args...); err != nil {
			return handler.OnError(err, EventParameters{Context: ctx, Database: db, Operation: Append})
		}
	} else {
		if err := db.QueryRow(query, args...).Scan(ret...); err != nil {
			return handler.OnError(err, EventParameters{Context: ctx, Database: db, Operation: Append})
		}
	}

	// executa o event handler
	if hasHandler {
		if err := handler.AfterAppend(EventParameters{Context: ctx, Database: db}); err != nil {
			return err
		}
	}

	w.lastop = Append

	if !db.WithinTransaction() {
		w.Freeze()
	} else {
		db.StoreWorkarea(w)
	}

	return nil
}

// Replace realiza um update no banco de dados
func (w *workarea[T]) Replace(ctx context.Context, db Database) error {
	// verifica se implementa o event handler
	handler, hasHandler := implements[Workarea[T]](w)

	// executa o event handler
	if hasHandler {
		if err := handler.BeforeReplace(EventParameters{Context: ctx, Database: db}); err != nil {
			return err
		}
	}

	// executa o update
	query, args, ret, err := db.Builder().Update(*w.schema, w.Fields())
	if err != nil {
		return err
	}

	//fmt.Println(query)

	if len(ret) == 0 {
		if _, err := db.Exec(query, args...); err != nil {
			return handler.OnError(err, EventParameters{Context: ctx, Database: db, Operation: Append})
		}
	} else {
		if err := db.QueryRow(query, args...).Scan(ret...); err != nil {
			return handler.OnError(err, EventParameters{Context: ctx, Database: db, Operation: Append})
		}
	}

	// executa o event handler
	if hasHandler {
		if err := handler.AfterReplace(EventParameters{Context: ctx, Database: db}); err != nil {
			return err
		}
	}

	w.lastop = Replace

	if !db.WithinTransaction() {
		w.Freeze()
	} else {
		db.StoreWorkarea(w)
	}

	return nil
}

// Remove realiza um delete no banco de dados
func (w *workarea[T]) Remove(ctx context.Context, db Database) error {
	// verifica se implementa o event handler
	handler, hasHandler := implements[Workarea[T]](w)

	// executa o event handler
	if hasHandler {
		if err := handler.BeforeRemove(EventParameters{Context: ctx, Database: db}); err != nil {
			return err
		}
	}

	// executa o update
	query, args := db.Builder().Delete(*w.schema, w.Fields())

	//fmt.Println(query)

	if _, err := db.Exec(query, args...); err != nil {
		return handler.OnError(err, EventParameters{Context: ctx, Database: db, Operation: Append})
	}

	// executa o event handler
	if hasHandler {
		if err := handler.AfterRemove(EventParameters{Context: ctx, Database: db}); err != nil {
			return err
		}
	}

	w.lastop = Delete

	if !db.WithinTransaction() {
		w.Freeze()
	} else {
		db.StoreWorkarea(w)
	}

	return nil
}

// Changed verifica se houve alguma alteração nos campos da workarea
func (w *workarea[T]) Changed() bool {
	for _, v := range w.fields {
		if f, ok := v.Addr.(field.Changeable); ok {
			if f.Changed() {
				return true
			}
		}
	}
	return false
}

// Freeze congela as informações. Após isso o Changed retorna falso
func (w *workarea[T]) Freeze() {
	for _, v := range w.fields {
		if f, ok := v.Addr.(field.Freezable); ok {
			f.Freeze()
		}
	}
}

// Reset zera as informações da workarea.
func (w *workarea[T]) Reset() {
	w.lastop = None
	for _, v := range w.fields {
		if f, ok := v.Addr.(field.Resetable); ok {
			f.Reset()
		}
	}
}

// Load carrega uma estrutura para a workarea
func (w *workarea[T]) Load(src any) error {
	rv := reflect.ValueOf(src)
	rt := reflect.TypeOf(src)

	for i := 0; i < rv.NumField(); i++ {
		sv := rv.Field(i).Interface()

		if columnName, ok := rt.Field(i).Tag.Lookup("rdd-column"); ok {
			if field, ok := w.fields[columnName]; ok {
				w.setField(field, sv)
			}
		}
	}

	return nil
}

func (w *workarea[T]) setField(fi field.FieldInstance, sv any) {
	switch v := sv.(type) {
	case string:
		(fi.Addr.(*field.Field[string])).Set(v)
	case int64:
		(fi.Addr.(*field.Field[int64])).Set(v)
	case float64:
		(fi.Addr.(*field.Field[float64])).Set(v)
	case bool:
		(fi.Addr.(*field.Field[bool])).Set(v)
	case time.Time:
		(fi.Addr.(*field.Field[time.Time])).Set(v)
	}
}

// BeforeAppend é executado antes de adicionar o registro no banco de dados
func (w *workarea[T]) BeforeAppend(params EventParameters) error { return nil }

// AfterAppend é executado depois de adicionar o registro no banco de dados
func (w *workarea[T]) AfterAppend(params EventParameters) error { return nil }

// BeforeReplace é executado antes de alterar o registro no banco de dados
func (w *workarea[T]) BeforeReplace(params EventParameters) error { return nil }

// AfterReplace é executado depois de alterar o registro no banco de dados
func (w *workarea[T]) AfterReplace(params EventParameters) error { return nil }

// BeforeRemove é executado antes de remover o registro no banco de dados
func (w *workarea[T]) BeforeRemove(params EventParameters) error { return nil }

// AfterRemove é executado depois de remover o registro no banco de dados
func (w *workarea[T]) AfterRemove(params EventParameters) error { return nil }

// AfterCommit é executado depois de confirmar a transação no banco de dados
func (w *workarea[T]) AfterCommit(params EventParameters) error { return nil }

// OnError
func (w *workarea[T]) OnError(err error, params EventParameters) error { return nil }

func implements[I, T any](w *workarea[T]) (I, bool) {
	c, ok := any(w.entity).(I)
	return c, ok
}

func (w *workarea[T]) Fields() []field.FieldInstance {
	fields := make([]field.FieldInstance, len(w.fields))

	i := 0
	for _, v := range w.fields {
		fields[i] = v
		i++
	}

	return fields
}

func (w *workarea[T]) Seek(db Database) error       { return nil }
func (w *workarea[T]) SeekUnique(db Database) error { return nil }
